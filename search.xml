<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[my new post]]></title>
    <url>%2F2017%2F03%2F09%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[测试博客下周也许是我们在这的最后一周… Touch事件传递的开始Activity中主要两个与事件传递相关的方法，dispatchTouchEvent()和onTouchEvent()，事件传递由Activity的dispatchTouchEvent()方法开始 1.事件分发Activity中的事件分发方法：dispatchTounchEvent()，其源码如下： 12345678910111213//事件分发public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //空方法 onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; //onTouchEvent()方法默认返回false return onTouchEvent(ev);&#125; 上面代码中调用了Window类的superDispatchTouchEvent(ev)方法，这是一个抽象方法，那么当调用这个方法的时候，就会去调用具体子类中的方法，Window类的具体子类就是PhoneWindow类，里面的具体实现的superDispatchTouchEvent(ev)方法如下： 1234567//Window类里面的抽象方法public abstract boolean superDispatchTouchEvent(MotionEvent event);//Windoe子类PhoneWindow类中superDispatchTouchEvent()方法的具体实现@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 显然，这里有调用了mDecor.superDispatchTouchEvent(event)，mDecor是一个PhoneWindow.DecorView对象，这也是窗口的顶层视图。它是一个真正Activity的root view,它继承了FrameLayout,通过super.dispatchTouchEvent，会把touchevent派发给各个activity的子view，也就是我们在Activity.onCreat方法中setContentView时设置的view,代码参考如下：123456789//DecorView类声明private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; ... public boolean superDispatchTouchEvent(MotionEvent event) &#123; //这里又调用了FrameLayout中的dispatchTouchEvent方法 return super.dispatchTouchEvent(event); &#125; ...&#125; 由于在FrameLayout并没有重写dispatchTouchEvent(event)方法，因此我们需要FrameLayout的父类也就是ViewGroup中该方法的实现，由该方法进行事件的具体分发，这里具体事件分发过程有待研究。 2.事件处理Activity中的事件处理方法：onTouchEvent()，其源码如下：123456789//事件处理,默认返回falsepublic boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; //默认返回false return false; &#125; 由于对于onTouchEvent()方法来说，事件传递是向父控件传递的，即使返回false,事件也相当于被消费了。 总结： Activity中拥有与事件相关的两个方法dispatchTouchEvent()和onTouchEvent()。 Activity进行事件分发时，只有return super.dispatchTouchEvent(ev)时，事件才继续向下传递，返回true或false都事件就被消费了，也就是终止了事件的传播。ViewGroupViewGroup中主要三个与事件传递相关的方法：dispatchTouchEvent()、onInterceptTouchEvent()和onTouchEvent()。1.事件分发ViewGroup中的事件分发方法：dispatchTouchEvent()，其源码如下： 12345678910111213@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; //给方法决定是否拦截事件的分发 onInterceptTouchEvent(ev); ... //该方法将事件传递给子View dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; ... return handled;&#125; 这个方法的作用就是遍历ViewGroup中的子View,将事件(ACTION_DOWN)交有子View进行处理，里面主要调用了onInterceptTouchEvent()和dispatchTransformedTouchEvent()方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>github</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>