<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView的简单使用]]></title>
    <url>%2F2017%2F05%2F14%2FRecyclerView%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[自从Android 5.0之后，google退出了一个RecyclerView控件，他是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，RecyclerView相当于是ListView的升级版，相较ListView其优点如下： RecyclerView封装了ViewHolder的回收复用，也就是说RecyclerView标准化了ViewHolder,编写Adapter面向的是ViewHolder而不是View了，复用的逻辑被封装了，写起来更加简单。 提供一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取了相应的类，来控制Item的显示，使其的扩展性特别强。 引入RecyclerVIew1compile 'com.android.support:recyclerview-v7:25.1.0' 创建布局文件主布局文件1234567891011121314/*activity_main.xml*/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.manu.mrecyclerview.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; Item布局文件1234567891011121314151617/*item.xml*/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_recycle" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_horizontal" android:text="data" android:background="#cac3c3" android:padding="10dp" android:textSize="20sp"/&gt;&lt;/LinearLayout&gt; 创建Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by jzman on 2017/5/13 0013. */public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.DataViewHolder&gt;&#123; private Context mContext; private ArrayList&lt;String&gt; mList; public RvAdapter() &#123;&#125; public RvAdapter(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; //用于创建ViewHolder @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; //绑定数据 @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; holder.tv_data.setText(mList.get(position)); &#125; //数据总数 @Override public int getItemCount() &#123; return mList.size(); &#125; //创建ViewHolder public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; 使用StaggeredGridLayoutManager管理器时，Adapter参考如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Created by jzman on 2017/5/13 0013. * RecycleView的Adapter */public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.DataViewHolder&gt;&#123; private Context mContext; private RecyclerView recyclerView; private ArrayList&lt;String&gt; mList; private ArrayList&lt;Integer&gt; mHeight; public RvAdapter() &#123;&#125; public RvAdapter(Context mContext, ArrayList&lt;String&gt; mList, RecyclerView recyclerView) &#123; this.mContext = mContext; this.mList = mList; this.recyclerView = recyclerView; &#125; /** * 初始化每个Item的高度（瀑布流效果） * @return */ public ArrayList&lt;Integer&gt; initHeight()&#123; mHeight = new ArrayList&lt;&gt;(); for (int i=0;i&lt;mList.size();i++)&#123; mHeight.add((int) (Math.random()*300)+200); &#125; return mHeight; &#125; /** * 用于创建ViewHolder * @param parent * @param viewType * @return */ @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; /** * 绑定数据 * @param holder * @param position */ @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; //设置每个Item的高度 ViewGroup.LayoutParams h = holder.tv_data.getLayoutParams(); h.height = mHeight.get(position); holder.tv_data.setText(mList.get(position)); &#125; /** * 选项总数 * @return */ @Override public int getItemCount() &#123; return mList.size(); &#125; /** * 创建ViewHolder */ public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; /** * 将RecycleView附加到Adapter上 */ @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); this.recyclerView= recyclerView; initHeight(); &#125; /** * 将RecycleView从Adapter解除 */ @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123; super.onDetachedFromRecyclerView(recyclerView); this.recyclerView = null; &#125; MainActivity1234567891011121314151617181920212223242526/** * Created by jzman on 2017/5/13 0013. */public class MainActivity extends AppCompatActivity &#123; private RecyclerView rv; RvAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); //设置布局管理器 rv.setLayoutManager(new LinearLayoutManager(this));//线性// rv.setLayoutManager(new GridLayoutManager(this,4));//线性// rv.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL));//线性 adapter = new RvAdapter(this,initData()); rv.setAdapter(adapter); &#125; public static ArrayList&lt;String&gt; initData()&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; arrayList.add("第"+i+"条数据"); &#125; return arrayList; &#125;&#125; 使用StaggeredGridLayoutManager管理器时，MainActivity参考如下： 1234567891011121314151617181920212223242526/** * Created by jzman on 2017/5/13 0013. */public class MainActivity extends AppCompatActivity &#123; private RecyclerView rv; RvAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); //设置布局管理器// rv.setLayoutManager(new LinearLayoutManager(this));//线性// rv.setLayoutManager(new GridLayoutManager(this,4));//线性 rv.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL));//线性 adapter = new RvAdapter(this,initData(),rv); rv.setAdapter(adapter); &#125; public static ArrayList&lt;String&gt; initData()&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; arrayList.add("第"+i+"条数据"); &#125; return arrayList; &#125;&#125; 显示效果 LinearLayoutManager GridLayoutManager StaggeredGridLayoutManager &lt;完&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my new post]]></title>
    <url>%2F2017%2F03%2F09%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[测试博客下周也许是我们在这的最后一周… Touch事件传递的开始Activity中主要两个与事件传递相关的方法，dispatchTouchEvent()和onTouchEvent()，事件传递由Activity的dispatchTouchEvent()方法开始 1.事件分发Activity中的事件分发方法：dispatchTounchEvent()，其源码如下： 12345678910111213//事件分发public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //空方法 onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; //onTouchEvent()方法默认返回false return onTouchEvent(ev);&#125; 上面代码中调用了Window类的superDispatchTouchEvent(ev)方法，这是一个抽象方法，那么当调用这个方法的时候，就会去调用具体子类中的方法，Window类的具体子类就是PhoneWindow类，里面的具体实现的superDispatchTouchEvent(ev)方法如下： 1234567//Window类里面的抽象方法public abstract boolean superDispatchTouchEvent(MotionEvent event);//Windoe子类PhoneWindow类中superDispatchTouchEvent()方法的具体实现@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 显然，这里有调用了mDecor.superDispatchTouchEvent(event)，mDecor是一个PhoneWindow.DecorView对象，这也是窗口的顶层视图。它是一个真正Activity的root view,它继承了FrameLayout,通过super.dispatchTouchEvent，会把touchevent派发给各个activity的子view，也就是我们在Activity.onCreat方法中setContentView时设置的view,代码参考如下：123456789//DecorView类声明private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; ... public boolean superDispatchTouchEvent(MotionEvent event) &#123; //这里又调用了FrameLayout中的dispatchTouchEvent方法 return super.dispatchTouchEvent(event); &#125; ...&#125; 由于在FrameLayout并没有重写dispatchTouchEvent(event)方法，因此我们需要FrameLayout的父类也就是ViewGroup中该方法的实现，由该方法进行事件的具体分发，这里具体事件分发过程有待研究。 2.事件处理Activity中的事件处理方法：onTouchEvent()，其源码如下：123456789//事件处理,默认返回falsepublic boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; //默认返回false return false; &#125; 由于对于onTouchEvent()方法来说，事件传递是向父控件传递的，即使返回false,事件也相当于被消费了。 总结： Activity中拥有与事件相关的两个方法dispatchTouchEvent()和onTouchEvent()。 Activity进行事件分发时，只有return super.dispatchTouchEvent(ev)时，事件才继续向下传递，返回true或false都事件就被消费了，也就是终止了事件的传播。ViewGroupViewGroup中主要三个与事件传递相关的方法：dispatchTouchEvent()、onInterceptTouchEvent()和onTouchEvent()。1.事件分发ViewGroup中的事件分发方法：dispatchTouchEvent()，其源码如下： 12345678910111213@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; //给方法决定是否拦截事件的分发 onInterceptTouchEvent(ev); ... //该方法将事件传递给子View dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; ... return handled;&#125; 这个方法的作用就是遍历ViewGroup中的子View,将事件(ACTION_DOWN)交有子View进行处理，里面主要调用了onInterceptTouchEvent()和dispatchTransformedTouchEvent()方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>github</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>