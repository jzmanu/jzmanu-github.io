<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView的刷新分页]]></title>
    <url>%2F2017%2F06%2F04%2FRecyclerView%E7%9A%84%E5%88%B7%E6%96%B0%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[在开发中常常使用到刷新分页，这里实现一个 RecyclerView 的简单的刷新分页操作。 实现思路 加载更多数据使用到 RecyclerView 加载多种布局，根据 ViewType 判断加载数据 Item 还是加载 FooterItem ; 通过线程模拟加载数据; 为 RecyclerView 添加 addOnScrollListener 事件来监听用户的滑动操作; 根据用户滑动状态以及具体情况开始加载数据 通知数据更新; 如何获得 firstVisibleItemPosition为了能够在数据加载中动态判断什么时候加载数据，需要知道屏幕上显示的第一个可见的 Item 的位置，当然了这里使用的是布局管理器是 LinearLayoutManager ,这样查找屏幕上第一个可见的 Item 就显得容易多了，下面介绍一些 LinearLayoutManager 的四个方法： findFirstVisibleItemPosition()获得屏幕上第一个可见 Item 的 position，只要该 Item 有一部分可见，那么返回的 position 就是该Item 的 position。 findFirstCompletelyVisibleItemPosition()获得屏幕上第一个完整可见的 Item 的 position，只要该 Item 有一部分不可见，那么返回的 position 就是该 Item 对应的下一个能显示完整的 Item 的position。 findLastVisibleItemPosition()获得屏幕上最后一个可见 Item 的 position，只要该 Item 有一部分可见，那么返回的 position 就是该Item 的 position。 findLastCompletelyVisibleItemPosition()获得屏幕上最后一个完整可见的 Item 的 position，只要该 Item 有一部分不可见，那么返回的 position 就是该 Item 对应的上一个能显示完整的 Item 的position。 准备数据1234567891011121314151617181920212223242526272829/** * 初始化数据 * @return */public void initData()&#123; for (int i=0;i&lt;30;i++)&#123; arrayList.add("第"+i+"条数据"); &#125;&#125;/** * 线程模拟加载数据 */class LoadDataThread extends Thread&#123; @Override public void run() &#123; initData(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //通知主线程更新数据 Message message = handler.obtainMessage(); message.what = UPDATE_DATA; message.obj = arrayList; handler.sendMessage(message); &#125;&#125; 代码参考主布局1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.manu.mrecyclerview.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; Item布局1234567891011121314151617/**item.xml**/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_recycle" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_horizontal" android:text="data" android:background="#cac3c3" android:padding="10dp" android:textSize="20sp"/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718/**item_footer.xml**/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center_horizontal"&gt; &lt;ProgressBar style="?android:attr/progressBarStyleSmall" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/progressBar" /&gt; &lt;TextView android:text="正在努力加载中，请稍后..." android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/textView" /&gt;&lt;/LinearLayout&gt; Adapter这里使用了 RecyclerView 根据不同的 ViewType 加载多种布局的用法，使用时根据不同的布局创建不同的 ViewHolder , 然后根据不同的 Viewholder 为对应的 Item 添加数据，注意 getItemViewType() 方法的用法，Adapter 代码参考如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/** * Created by jzman on 2017/6/04 * RecycleView的Adapter */public class RvAdapter1 extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; implements View.OnClickListener&#123; private static final int ITEM_FOOTER = 0x1; private static final int ITEM_DATA = 0x2; private Context mContext; private RecyclerView recyclerView; private ArrayList&lt;String&gt; mList; public RvAdapter1() &#123;&#125; public RvAdapter1(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; public void setmList(ArrayList&lt;String&gt; mList) &#123; this.mList = mList; &#125; /** * 用于创建ViewHolder * @param parent * @param viewTypez * @return */ @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view ; RecyclerView.ViewHolder vh = null; switch (viewType)&#123; case ITEM_DATA: view = LayoutInflater.from(mContext).inflate(R.layout.item,null); view.setOnClickListener(this); vh = new DataViewHolder(view); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); break; case ITEM_FOOTER: view = LayoutInflater.from(mContext).inflate(R.layout.item_footer,null); //使用代码设置宽高（xml布局设置无效时） vh = new FooterViewHolder(view); view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); break; &#125; return vh; &#125; /** * 获取Item的View类型 * @param position * @return */ @Override public int getItemViewType(int position) &#123; //根据 Item 的 position 返回不同的 Viewtype if (position == (getItemCount())-1)&#123; return ITEM_FOOTER; &#125;else&#123; return ITEM_DATA; &#125; &#125; /** * 绑定数据 * @param holder * @param position */ @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof DataViewHolder)&#123; DataViewHolder dataViewHolder = (DataViewHolder) holder; dataViewHolder.tv_data.setText(mList.get(position)); &#125;else if (holder instanceof FooterViewHolder)&#123; &#125; &#125; /** * 选项总数 * @return */ @Override public int getItemCount() &#123; return mList.size()+1; &#125; @Override public void onClick(View view) &#123; //根据RecyclerView获得当前View的位置 int position = recyclerView.getChildAdapterPosition(view); //程序执行到此，会去执行具体实现的onItemClick()方法 if (onItemClickListener!=null)&#123; onItemClickListener.onItemClick(recyclerView,view,position,mList.get(position)); &#125; &#125; /** * 创建ViewHolder */ public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; /** * 创建footer的ViewHolder */ public static class FooterViewHolder extends RecyclerView.ViewHolder&#123; public FooterViewHolder(View itemView) &#123; super(itemView); &#125; &#125; private OnItemClickListener onItemClickListener; public void setOnItemClickListener(OnItemClickListener onItemClickListener)&#123; this.onItemClickListener = onItemClickListener; &#125; /** * 定义RecyclerView选项单击事件的回调接口 */ public interface OnItemClickListener&#123; //参数（父组件，当前单击的View,单击的View的位置，数据） void onItemClick(RecyclerView parent,View view, int position, String data); &#125; /** * 将RecycleView附加到Adapter上 */ @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); this.recyclerView= recyclerView; &#125; /** * 将RecycleView从Adapter解除 */ @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123; super.onDetachedFromRecyclerView(recyclerView); this.recyclerView = null; &#125;&#125; MainActivity这里主要注意 rv.addOnScrollListener(new OnScrollListener() …里面的具体实现，MainActivity 代码参考如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Created by jzman on 2017/6/04 0013. */public class MainActivity extends AppCompatActivity &#123; private static final int UPDATE_DATA = 0x3; private RecyclerView rv; RvAdapter1 adapter; private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); //加载更多数据时最后一项的索引 private int lastLoadDataItemPosition; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); //设置布局管理器 rv.setLayoutManager(new LinearLayoutManager(this));//线性// rv.setLayoutManager(new GridLayoutManager(this,4));//线性// rv.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL));//线性 initData(); adapter = new RvAdapter1(this,arrayList); adapter.setOnItemClickListener(new RvAdapter1.OnItemClickListener() &#123; @Override public void onItemClick(RecyclerView parent, View view, int position, String data) &#123; Toast.makeText(MainActivity.this, data, Toast.LENGTH_SHORT).show(); &#125; &#125;); rv.addOnScrollListener(new OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; if (newState == SCROLL_STATE_IDLE &amp;&amp; lastLoadDataItemPosition == adapter.getItemCount())&#123; new LoadDataThread().start(); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof LinearLayoutManager)&#123; LinearLayoutManager manager = (LinearLayoutManager) layoutManager; int firstVisibleItem = manager.findFirstVisibleItemPosition(); int l = manager.findLastCompletelyVisibleItemPosition(); lastLoadDataItemPosition = firstVisibleItem+(l-firstVisibleItem)+1; &#125; &#125; &#125;); rv.setAdapter(adapter); &#125; /** * 初始化数据 * @return */ public void initData()&#123; for (int i=0;i&lt;25;i++)&#123; arrayList.add("第"+i+"条数据"); &#125; &#125; /** * 线程模拟加载数据 */ class LoadDataThread extends Thread&#123; @Override public void run() &#123; initData(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Message message = handler.obtainMessage(); message.what = UPDATE_DATA; message.obj = arrayList; handler.sendMessage(message); &#125; &#125; private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what)&#123; case UPDATE_DATA: arrayList = (ArrayList&lt;String&gt;) msg.obj; adapter.setmList(arrayList); adapter.notifyDataSetChanged(); break; &#125; &#125; &#125;;&#125; 测试效果 &lt;完&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView实现拖动排序和滑动删除功能]]></title>
    <url>%2F2017%2F05%2F22%2FRecyclerView%E5%AE%9E%E7%8E%B0%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F%E5%92%8C%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[RecyclerView 的拖动排序需要借助一下 ItemTouchHelper 这个类，ItemTouchHelper 类是 Google 提供的一个支持 RecyclerView 滑动和拖动的一个使用类，下面使用该类实现 RecyclerView 的滑动删除和拖动排序功能。首先大概介绍一下 ItemTouchHelper 的一个内部抽象类 Callback 类。 ItemTouchHelper.Callback该类是ItemTouchHelper类中的一个静态抽象类，作用主要是将ItemTouchHelper于自己的应用联系在一起，让开发者通过ViewHolder控制每一个View的具体行为，接收用户的事件回调。该类里面有三个抽象方法：getMovementFlags、onMove、onSwiped。也是开发中经常要是用的。 getMovementFlags该方法返回一个Flags表示Item的三种状态状态：idle(空闲)、 swiping(滑动)、dragging(拖动)，根据RecyclerView不同的布局管理器，设置不同的滑动、拖动方向，一般使用makeMovementFlags(int dragFlags, int swipeFlags)方法返回，dragFlags表示拖动的方向，swipeFlags表示滑动的方向。1public abstract int getMovementFlags(RecyclerView recyclerView, ViewHolder viewHolder); onMove当ItemTouchHelper拖动一个Item时该方法将会被回调，Item将从旧的位置移动到新的位置，如果不拖动这个方法将从来不会调用,返回true表示Item已经被移动到新的位置。 1public abstract boolean onMove(RecyclerView recyclerView, ViewHolder viewHolder, ViewHolder target); onSwiped当Item滑动的时候调用，如果不滑动该方法不会被调用，可通过direction做相应的判断执行某些操作。 1public abstract void onSwiped(ViewHolder viewHolder, int direction); 此外经常使用的方法有 onSelectedChanged、clearView等方法。 onSelectedChanged当item由静止状态变为滑动或拖动状态时调用此方法，可通过actionState判断Item在哪种状态下执行某些操作，重写该方法时必须调用其父类的该方法。 12345public void onSelectedChanged(ViewHolder viewHolder, int actionState) &#123; if (viewHolder != null) &#123; sUICallback.onSelected(viewHolder.itemView); &#125;&#125; clearView当与用户交互结束或相关动画完成之后被 调用该方法被调用。123public void clearView(RecyclerView recyclerView, ViewHolder viewHolder) &#123; sUICallback.clearView(viewHolder.itemView);&#125; RecyclerView实现拖动排序RecyclerView的拖动排序需要借助一个 android.support.v7.widget.helper.ItemTouchHelper 这个类来实现，拖动排序重点是在接口里面的 onMove(int fromPosition, int toPosition) 方法，其在GridAdapter中的具体实现参考如下： 12345678910111213@Overridepublic void onMove(int fromPosition, int toPosition) &#123; if (fromPosition &lt; toPosition) &#123; for (int i = fromPosition; i &lt; toPosition; i++) &#123; Collections.swap(list, i, i + 1); &#125; &#125; else &#123; for (int i = fromPosition; i &gt; toPosition; i--) &#123; Collections.swap(list, i, i - 1); &#125; &#125; notifyItemMoved(fromPosition, toPosition);&#125; RecyclerView实现侧滑删除RecyclerView的拖动排序需要借助一个 android.support.v7.widget.helper.ItemTouchHelper 这个类来实现，侧滑删除重点是在接口中的 onSwiped(int position)，其在GridAdapter中的具体实现参考如下： 参考代码ItemTouchHelper.Callback 的实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Created by jzman on 2017/5/17 0015. */public class ItemTouchCallBack extends ItemTouchHelper.Callback &#123; private static final String TAG = "drag"; private OnItemTouchListener onItemTouchListener; public void setOnItemTouchListener(OnItemTouchListener onItemTouchListener) &#123; this.onItemTouchListener = onItemTouchListener; &#125; /** * 根据 RecyclerView 不同的布局管理器，设置不同的滑动、拖动方向 * 该方法使用 makeMovementFlags(int dragFlags, int swipeFlags) 方法返回 * 参数: dragFlags:拖动的方向 * swipeFlags:滑动的方向 * @param recyclerView * @param viewHolder * @return */ @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; Log.i(TAG,"getMovementFlags"); if (recyclerView.getLayoutManager() instanceof GridLayoutManager || recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager)&#123; //此处不需要进行滑动操作，可设置为除4和8之外的整数，这里设为0 //不支持滑动 return makeMovementFlags(ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT, 0 ); &#125;else &#123; //如果是LinearLayoutManager则只能向上向下滑动， //此处第二个参数设置支持向右滑动 return makeMovementFlags(ItemTouchHelper.UP | ItemTouchHelper.DOWN , ItemTouchHelper.RIGHT ); &#125; &#125; /** * 当 ItemTouchHelper 拖动一个Item时该方法将会被回调，Item将从旧的位置移动到新的位置 * 如果不拖动这个方法将从来不会调用,返回true表示已经被移动到新的位置 * @param recyclerView * @param viewHolder * @param target * @return */ @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; Log.i(TAG,"onMove"); int fromPosition = viewHolder.getAdapterPosition(); int toPosition = target.getAdapterPosition(); onItemTouchListener.onMove(fromPosition,toPosition); return true; &#125; /** * 当Item被滑动的时候被调用 * 如果你不滑动这个方法将不会被调用 * @param viewHolder * @param direction */ @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; Log.i(TAG,"onSwiped"); //此处是侧滑删除的主要代码 int position = viewHolder.getAdapterPosition(); onItemTouchListener.onSwiped(position); &#125; /** * 当Item被滑动、拖动的时候被调用 * @param viewHolder * @param actionState */ @Override public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123; Log.i(TAG,"onSelectedChanged"); //... super.onSelectedChanged(viewHolder, actionState); &#125; /** * 当与用户交互结束或相关动画完成之后被调用 * @param recyclerView * @param viewHolder */ @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; Log.i(TAG,"clearView"); //... super.clearView(recyclerView, viewHolder); &#125; /** * 移动交换数据的更新监听 */ public interface OnItemTouchListener &#123; //拖动Item时调用 void onMove(int fromPosition, int toPosition); //滑动Item时调用 void onSwiped(int position); &#125;&#125; Adapter的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Created by jzman on 2017/05/17 0009. * RecycleView的Adapter */public class GridAdapter extends RecyclerView.Adapter&lt;GridAdapter.DataViewHolder&gt; implements View.OnClickListener,ItemTouchCallBack.OnItemTouchListener &#123; private Context context; private List&lt;SimpleTitleGrid&gt; list; public GridAdapter(Context context, List&lt;SimpleTitleGrid&gt; list) &#123; this.context = context; this.list = list; &#125; /** * 创建ViewHolder * @param parent * @param viewType * @return */ @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //加载item布局文件(每一个) View view = LayoutInflater.from(context).inflate(R.layout.item,null); //为View设置单击事件 view.setOnClickListener(this); DataViewHolder viewHolder = new DataViewHolder(view); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new RecyclerView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); return viewHolder; &#125; /** * 绑定数据 * @param holder * @param position */ @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; //设置每一个Item的高度 holder.textView.setText(list.get(position).getTitle()); &#125; /** * 选项总数 * @return */ @Override public int getItemCount() &#123; return list.size(); &#125; /** * 单击事件 * @param v */ @Override public void onClick(View v) &#123; if(onItemClickListener!=null)&#123; int position = recyclerView.getChildAdapterPosition(v); //程序执行到此，会执行该方法的具体实现 onItemClickListener.onItemClick(recyclerView,v,position,list.get(position)); &#125; &#125; @Override public void onMove(int fromPosition, int toPosition) &#123; if (fromPosition &lt; toPosition) &#123; for (int i = fromPosition; i &lt; toPosition; i++) &#123; Collections.swap(list, i, i + 1); &#125; &#125; else &#123; for (int i = fromPosition; i &gt; toPosition; i--) &#123; Collections.swap(list, i, i - 1); &#125; &#125; notifyItemMoved(fromPosition, toPosition); &#125; @Override public void onSwiped(int position) &#123; Log.i(&quot;drag&quot;,&quot;onSwiped&quot;); list.remove(position); notifyItemRemoved(position); &#125; /** * RecycleView中针对ViewHolder来实现 */ public static class DataViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; public DataViewHolder(View itemView) &#123; super(itemView); textView = (TextView) itemView.findViewById(R.id.tv_grid); &#125; &#125; private RecyclerView recyclerView; private OnItemClickListener onItemClickListener; public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; this.onItemClickListener = onItemClickListener; &#125; /** * 设计recycleView选项单击事件的回调接口（给外面使用） * 参考ListView选项单击事件方法 */ public interface OnItemClickListener&#123; //参数（父组件，点击的View，位置，这里可能是某个对象的id或对象/这里不需要） void onItemClick(RecyclerView recyclerView, View view, int position, SimpleTitleGrid obj); &#125; /** * 将RecycleView附加到Adapter上 */ @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); this.recyclerView= recyclerView; &#125; /** * 将RecycleView从Adapter解除 */ @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123; super.onDetachedFromRecyclerView(recyclerView); this.recyclerView = null; &#125;&#125; MainActivity123456789101112131415161718192021222324252627282930313233343536/** * Created by jzman on 2017/05/17 0029. * RecycleView的Adapter */public class MainActivity extends AppCompatActivity implements GridAdapter.OnItemClickListener&#123; private RecyclerView rv_user; private GridAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; rv_user = (RecyclerView) findViewById(R.id.rv_user); adapter = new GridAdapter(this, DataUtils.getUserGrids()); ItemTouchCallBack touchCallBack = new ItemTouchCallBack(); touchCallBack.setOnItemTouchListener(adapter); ItemTouchHelper itemTouchHelper = new ItemTouchHelper(touchCallBack); rv_user.setLayoutManager(new GridLayoutManager(this,3));// rv_user.setLayoutManager(new LinearLayoutManager(this)); rv_user.setAdapter(adapter); itemTouchHelper.attachToRecyclerView(rv_user); adapter.setOnItemClickListener(this); &#125; @Override public void onItemClick(RecyclerView recyclerView, View view, int position, SimpleTitleGrid obj) &#123; Toast.makeText(MainActivity.this, obj.getTitle(), Toast.LENGTH_SHORT).show(); &#125;&#125; 显示效果 GridLayoutManager LinearLayoutManager &lt;完&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
        <tag>ItemTouchHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 的 Item 的单击事件]]></title>
    <url>%2F2017%2F05%2F17%2FRecyclerView%E7%9A%84Item%E7%9A%84%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[RecyclerView 的每个Item的点击事件并没有像ListView一样封装在组件中，需要Item的单击事件时就需要自己去实现，在Adapter中为RecyclerView添加单击事件参考如下： RecyclerView的使用方法请参考：RecyclerView的简单使用 第一步：在RecyclerView的Adapyer中定义单击事件的回调接口： 1234567/** * 定义RecyclerView选项单击事件的回调接口 */public interface OnItemClickListener&#123; //参数（父组件，当前单击的View,单击的View的位置，数据） void onItemClick(RecyclerView parent,View view, int position, String data);&#125; 第二步：在RecyclerView的Adapyer中声明该接口，并提供setter方法： 1234private OnItemClickListener onItemClickListener;public void setOnItemClickListener(OnItemClickListener onItemClickListener)&#123; this.onItemClickListener = onItemClickListener;&#125; 第三步：在RecyclerView的Adapyer类实现View.OnClickListener接口，并重写onClick(View view)方法，然后设置给接口的事件监听： 123456789101112131415public class RvAdapter1 extends RecyclerView.Adapter&lt;RvAdapter1.DataViewHolder&gt; implements View.OnClickListener&#123; ... view.setOnClickListener(this);//设置监听器 ... @Override public void onClick(View view) &#123; //根据RecyclerView获得当前View的位置 int position = recyclerView.getChildAdapterPosition(view); //程序执行到此，会去执行具体实现的onItemClick()方法 if (onItemClickListener!=null)&#123; onItemClickListener.onItemClick(recyclerView,view,position,mList.get(position)); &#125; &#125; ...&#125; 第四步：在MainActivity中通过Adapter设置每个Item的单击事件： 123456adapter.setOnItemClickListener(new RvAdapter1.OnItemClickListener() &#123; @Override public void onItemClick(RecyclerView parent, View view, int position, String data) &#123; Toast.makeText(MainActivity.this, data, Toast.LENGTH_SHORT).show(); &#125;&#125;); 参考代码Adapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Created by jzman on 2017/5/13 0013. * RecycleView的Adapter */public class RvAdapter1 extends RecyclerView.Adapter&lt;RvAdapter1.DataViewHolder&gt; implements View.OnClickListener&#123; private Context mContext; private RecyclerView recyclerView; private ArrayList&lt;String&gt; mList; public RvAdapter1() &#123;&#125; public RvAdapter1(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; /** * 用于创建ViewHolder * @param parent * @param viewType * @return */ @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); view.setOnClickListener(this); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; /** * 绑定数据 * @param holder * @param position */ @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; holder.tv_data.setText(mList.get(position)); &#125; /** * 选项总数 * @return */ @Override public int getItemCount() &#123; return mList.size(); &#125; @Override public void onClick(View view) &#123; //根据RecyclerView获得当前View的位置 int position = recyclerView.getChildAdapterPosition(view); //程序执行到此，会去执行具体实现的onItemClick()方法 if (onItemClickListener!=null)&#123; onItemClickListener.onItemClick(recyclerView,view,position,mList.get(position)); &#125; &#125; /** * 创建ViewHolder */ public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; private OnItemClickListener onItemClickListener; public void setOnItemClickListener(OnItemClickListener onItemClickListener)&#123; this.onItemClickListener = onItemClickListener; &#125; /** * 定义RecyclerView选项单击事件的回调接口 */ public interface OnItemClickListener&#123; //参数（父组件，当前单击的View,单击的View的位置，数据） void onItemClick(RecyclerView parent,View view, int position, String data); &#125; /** * 将RecycleView附加到Adapter上 */ @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); this.recyclerView= recyclerView; &#125; /** * 将RecycleView从Adapter解除 */ @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123; super.onDetachedFromRecyclerView(recyclerView); this.recyclerView = null; &#125;&#125; MainActivity123456789101112131415161718192021222324252627282930313233/** * Created by jzman on 2017/5/13 0013. */public class MainActivity extends AppCompatActivity &#123; private RecyclerView rv; RvAdapter1 adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); //设置布局管理器// rv.setLayoutManager(new LinearLayoutManager(this));//线性 rv.setLayoutManager(new GridLayoutManager(this,4));//线性// rv.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL));//线性 adapter = new RvAdapter1(this,initData()); adapter.setOnItemClickListener(new RvAdapter1.OnItemClickListener() &#123; @Override public void onItemClick(RecyclerView parent, View view, int position, String data) &#123; Toast.makeText(MainActivity.this, data, Toast.LENGTH_SHORT).show(); &#125; &#125;); rv.setAdapter(adapter); &#125; public static ArrayList&lt;String&gt; initData()&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; arrayList.add("第"+i+"条数据"); &#125; return arrayList; &#125;&#125; 显示效果 &lt;完&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerRiew的简单使用]]></title>
    <url>%2F2017%2F05%2F14%2FRecyclerRiew%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[自从Android 5.0之后，google退出了一个RecyclerView控件，他是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，RecyclerView相当于是ListView的升级版。 RecyclerView封装了ViewHolder的回收复用，也就是说RecyclerView标准化了ViewHolder,编写Adapter面向的是ViewHolder而不是View了，复用的逻辑被封装了，写起来更加简单。 RecyclerView提供一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取了相应的类，来控制Item的显示，使其的扩展性特别强。 引入RecyclerVIew1compile 'com.android.support:recyclerview-v7:25.1.0' 创建布局文件主布局文件1234567891011121314/*activity_main.xml*/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.manu.mrecyclerview.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; Item布局文件1234567891011121314151617/*item.xml*/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_recycle" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_horizontal" android:text="data" android:background="#cac3c3" android:padding="10dp" android:textSize="20sp"/&gt;&lt;/LinearLayout&gt; 创建AdapterRecyclerView的Adapter要比ListView的Adapter设置起来稍微复杂一点，这也是RecyclerView高度解耦的体现，虽然代码复杂一点，但扩展性很好，下面介绍一下实现RecyclerView的Adapter的三个方法： onCreateViewHolder()该方法主要是为每个Item加载一个View，但是该方法返回的是一个ViewHolder，该方法吧View直接封装的ViewHolder中，然后我们面向的是ViewHolder这个实例，这个ViewHolder也由自己编写，但不用像ListView调用convertView.setTag(vh)和convertView.getTag()了。 onBindViewHolder()该方法主要用来把数据绑定在View上，直接提供一个ViewHolder而不是convertView。 getItemCount()该方法返回选项总数。 Adapter代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by jzman on 2017/5/13 0013. */public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.DataViewHolder&gt;&#123; private Context mContext; private ArrayList&lt;String&gt; mList; public RvAdapter() &#123;&#125; public RvAdapter(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; //用于创建ViewHolder @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; //绑定数据 @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; holder.tv_data.setText(mList.get(position)); &#125; //数据总数 @Override public int getItemCount() &#123; return mList.size(); &#125; //创建ViewHolder public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; 使用StaggeredGridLayoutManager管理器时，Adapter参考如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Created by jzman on 2017/5/13 0013. * RecycleView的Adapter */public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.DataViewHolder&gt;&#123; private Context mContext; private RecyclerView recyclerView; private ArrayList&lt;String&gt; mList; private ArrayList&lt;Integer&gt; mHeight; public RvAdapter() &#123;&#125; public RvAdapter(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; /** * 初始化每个Item的高度（瀑布流效果） * @return */ public ArrayList&lt;Integer&gt; initHeight()&#123; mHeight = new ArrayList&lt;&gt;(); for (int i=0;i&lt;mList.size();i++)&#123; mHeight.add((int) (Math.random()*300)+200); &#125; return mHeight; &#125; /** * 用于创建ViewHolder * @param parent * @param viewType * @return */ @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; /** * 绑定数据 * @param holder * @param position */ @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; //设置每个Item的高度 ViewGroup.LayoutParams h = holder.tv_data.getLayoutParams(); h.height = mHeight.get(position); holder.tv_data.setText(mList.get(position)); &#125; /** * 选项总数 * @return */ @Override public int getItemCount() &#123; return mList.size(); &#125; /** * 创建ViewHolder */ public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; /** * 将RecycleView附加到Adapter上 */ @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); this.recyclerView= recyclerView; //初始化每个Item的高度 initHeight(); &#125; /** * 将RecycleView从Adapter解除 */ @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123; super.onDetachedFromRecyclerView(recyclerView); this.recyclerView = null; &#125;&#125; MainActivity1234567891011121314151617181920212223242526/** * Created by jzman on 2017/5/13 0013. */public class MainActivity extends AppCompatActivity &#123; private RecyclerView rv; RvAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); //设置布局管理器 rv.setLayoutManager(new LinearLayoutManager(this));//线性// rv.setLayoutManager(new GridLayoutManager(this,4));//线性// rv.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL));//线性 adapter = new RvAdapter(this,initData()); rv.setAdapter(adapter); &#125; public static ArrayList&lt;String&gt; initData()&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; arrayList.add("第"+i+"条数据"); &#125; return arrayList; &#125;&#125; 显示效果 LinearLayoutManager GridLayoutManager StaggeredGridLayoutManager &lt;完&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>