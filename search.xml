<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerRiew的简单使用]]></title>
    <url>%2F2017%2F05%2F14%2FRecyclerRiew%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[自从Android 5.0之后，google退出了一个RecyclerView控件，他是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，RecyclerView相当于是ListView的升级版。 RecyclerView封装了ViewHolder的回收复用，也就是说RecyclerView标准化了ViewHolder,编写Adapter面向的是ViewHolder而不是View了，复用的逻辑被封装了，写起来更加简单。 RecyclerView提供一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取了相应的类，来控制Item的显示，使其的扩展性特别强。 引入RecyclerVIew1compile 'com.android.support:recyclerview-v7:25.1.0' 创建布局文件主布局文件1234567891011121314/*activity_main.xml*/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.manu.mrecyclerview.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; Item布局文件1234567891011121314151617/*item.xml*/&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_recycle" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_horizontal" android:text="data" android:background="#cac3c3" android:padding="10dp" android:textSize="20sp"/&gt;&lt;/LinearLayout&gt; 创建AdapterRecyclerView的Adapter要比ListView的Adapter设置起来稍微复杂一点，这也是RecyclerView高度解耦的体现，虽然代码复杂一点，但扩展性很好，下面介绍一下实现RecyclerView的Adapter的三个方法： onCreateViewHolder()该方法主要是为每个Item加载一个View，但是该方法返回的是一个ViewHolder，该方法吧View直接封装的ViewHolder中，然后我们面向的是ViewHolder这个实例，这个ViewHolder也由自己编写，但不用像ListView调用convertView.setTag(vh)和convertView.getTag()了。 onBindViewHolder()该方法主要用来把数据绑定在View上，直接提供一个ViewHolder而不是convertView。 getItemCount()该方法返回选项总数。 Adapter代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by jzman on 2017/5/13 0013. */public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.DataViewHolder&gt;&#123; private Context mContext; private ArrayList&lt;String&gt; mList; public RvAdapter() &#123;&#125; public RvAdapter(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; //用于创建ViewHolder @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; //绑定数据 @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; holder.tv_data.setText(mList.get(position)); &#125; //数据总数 @Override public int getItemCount() &#123; return mList.size(); &#125; //创建ViewHolder public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; 使用StaggeredGridLayoutManager管理器时，Adapter参考如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Created by jzman on 2017/5/13 0013. * RecycleView的Adapter */public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.DataViewHolder&gt;&#123; private Context mContext; private RecyclerView recyclerView; private ArrayList&lt;String&gt; mList; private ArrayList&lt;Integer&gt; mHeight; public RvAdapter() &#123;&#125; public RvAdapter(Context mContext, ArrayList&lt;String&gt; mList) &#123; this.mContext = mContext; this.mList = mList; &#125; /** * 初始化每个Item的高度（瀑布流效果） * @return */ public ArrayList&lt;Integer&gt; initHeight()&#123; mHeight = new ArrayList&lt;&gt;(); for (int i=0;i&lt;mList.size();i++)&#123; mHeight.add((int) (Math.random()*300)+200); &#125; return mHeight; &#125; /** * 用于创建ViewHolder * @param parent * @param viewType * @return */ @Override public DataViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item,null); //使用代码设置宽高（xml布局设置无效时） view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)); DataViewHolder holder = new DataViewHolder(view); return holder; &#125; /** * 绑定数据 * @param holder * @param position */ @Override public void onBindViewHolder(DataViewHolder holder, int position) &#123; //设置每个Item的高度 ViewGroup.LayoutParams h = holder.tv_data.getLayoutParams(); h.height = mHeight.get(position); holder.tv_data.setText(mList.get(position)); &#125; /** * 选项总数 * @return */ @Override public int getItemCount() &#123; return mList.size(); &#125; /** * 创建ViewHolder */ public static class DataViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_data; public DataViewHolder(View itemView) &#123; super(itemView); tv_data = (TextView) itemView.findViewById(R.id.tv_recycle); &#125; &#125; /** * 将RecycleView附加到Adapter上 */ @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); this.recyclerView= recyclerView; //初始化每个Item的高度 initHeight(); &#125; /** * 将RecycleView从Adapter解除 */ @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) &#123; super.onDetachedFromRecyclerView(recyclerView); this.recyclerView = null; &#125;&#125; MainActivity1234567891011121314151617181920212223242526/** * Created by jzman on 2017/5/13 0013. */public class MainActivity extends AppCompatActivity &#123; private RecyclerView rv; RvAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); //设置布局管理器 rv.setLayoutManager(new LinearLayoutManager(this));//线性// rv.setLayoutManager(new GridLayoutManager(this,4));//线性// rv.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL));//线性 adapter = new RvAdapter(this,initData()); rv.setAdapter(adapter); &#125; public static ArrayList&lt;String&gt; initData()&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; arrayList.add("第"+i+"条数据"); &#125; return arrayList; &#125;&#125; 显示效果 LinearLayoutManager GridLayoutManager StaggeredGridLayoutManager &lt;完&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>